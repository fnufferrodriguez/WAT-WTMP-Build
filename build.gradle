def checkForNexusCredentials() {
    if(!project.hasProperty('nexusUser')) {
        println ('Please set the nexusUser property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PnexusUser= .')
    }
    if(!project.hasProperty('nexusPassword')) {
        println ('Please set the nexusPassword property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PnexusPassword= .')
    }
}

def checkForRMANexusCredentials() {
    if(!project.hasProperty('rmaNexusUser')) {
        println ('Please set the rmaNexusUser property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PrmaNexusUser= .')
    }
    if(!project.hasProperty('rmaNexusPassword')) {
        println ('Please set the rmaNexusPassword property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PrmaNexusPassword= .')
    }
}

plugins {
    id "application"
    id "maven-publish"
    id "com.palantir.git-version" version "0.13.0"
    id "org.ajoberstar.grgit" version "1.7.2"
}

def versionLabel(gitInfo) {
    def branch = gitInfo.branchName // all branches are snapshots, only tags get released
    def tag = gitInfo.lastTag
    // tag is returned as is. Branch may need cleanup
    return branch == null ? tag : branch.replace("/","-") + "-SNAPSHOT"
}

group = 'gov.usbr'
version = versionLabel(versionDetails())

/**
 * When running on the Build System (eg TeamCity) will get BUILD_NUMBER
 * Otherwise, gets the current commit (and status)
 */
String getBuildID() {
    if(project.version.contains("-SNAPSHOT")) {
        def buildNum = System.env.BUILD_NUMBER
        if (!buildNum?.trim()) {
            buildNum = "-${grgit.head().abbreviatedId}"
            def clean = grgit.status().isClean()
            if (!clean) {
                buildNum += "+"
            }
        } else {
            buildNum = "." + buildNum
        }
        return buildNum
    } else {
        // If dirty, return "+"
        return grgit.status().isClean() ? "" : "+"
    }
}

String getShortVersionName() {
    String shortVersion = project.version
    if(shortVersion.contains("-SNAPSHOT")) {
        shortVersion = shortVersion.substring(0, shortVersion.indexOf("-SNAPSHOT"))
    }
    return shortVersion
}

repositories {
    maven {
        url 'https://www.hec.usace.army.mil/nexus/repository/maven-public'
    }
    maven {
        url 'https://www.hec.usace.army.mil/nexus/repository/hec-internal'
        credentials {
            checkForNexusCredentials()
            username "$nexusUser"
            password "$nexusPassword"
        }
    }
    maven {
        url 'https://artifact.rmanet.app/repository/rma-internal'
        credentials {
            checkForRMANexusCredentials()
            username "$rmaNexusUser"
            password "$rmaNexusPassword"
        }
    }
    mavenCentral()
    maven {
        url 'https://jaspersoft.jfrog.io/jaspersoft/third-party-ce-artifacts/'
    }
}

configurations {
    // The base WAT install
    wat_install
    // The extra upstream WAT plugins
    wat_plugins
    // The specific ResSim we want to use
    ressim_install
    // W2 Pre EXE, fixed name
    w2_pre_exe
    // W2 Post EXE, fixed name
    w2_post_exe
    // CeQualW2 executable
    cequalw2_exe
    // The TCD Variant required sometimes
    cequalw2_TCD_exe
    // CeQualW2 4.5 executable set
    cequalw2_45_exes
    // Extra Jars
    addl_wat_jars
    // The USBR WAT Plugins
    usbr_plugins
    // Python Report Generating code
    usbr_python_report
    // Python Git Tool
    usbr_python_git
    // Jasper files
    usbr_jasper
}

// WAT and upstream WAT Plugin Version
ext.wat_version = '1.1-DevNetAlpha-15'
// USBR Plugins and Python Version
ext.usbr_version = "0.0.8"
// USBR Git Tool Version
ext.usbr_git_version = "3.2.3"
// ResSim Version
ext.ressim_version = "4.0.0.QA-844-Not_For_Public_Release"
// USBR Fonts Version
ext.jasper_fonts_version = "1.0"

dependencies {
    wat_install "mil.army.usace.hec.wat:wat-install-package:${wat_version}-win-x86_64@zip"

    wat_plugins "mil.army.usace.hec.wat:wat-plugin-cequalw2:${wat_version}"
    wat_plugins "mil.army.usace.hec.wat:wat-plugin-ressim-4.0:${wat_version}"

    w2_pre_exe 'edu.pdx.ce.w2:w2-pre:4.0-win-x86_64@exe'
    w2_post_exe 'edu.pdx.ce.w2:w2-post:3.0-win-x86_64@exe'
    cequalw2_exe 'edu.pdx.ce.w2:w2:4.0-win-x86_64@exe'
    cequalw2_TCD_exe 'edu.pdx.ce.w2:w2:4.1-TCD-d7-win-x86_64@exe'

    cequalw2_45_exes 'edu.pdx.ce.w2:w2:4.5-win-x86_64@exe'
    cequalw2_45_exes 'edu.pdx.ce.w2:w2-pre-console:4.5-win-x86_64@exe'
    cequalw2_45_exes 'edu.pdx.ce.w2:w2-pre:4.5-win-x86_64'

    ressim_install "mil.army.usace.hec.ressim:hec-ressim:${ressim_version}@zip"

    usbr_plugins "usbr.wat.plugins:usbr-actionpanel-plugin:${usbr_version}"
    usbr_plugins "usbr.wat.plugins:usbr-comparison-report:${usbr_version}"
    usbr_plugins "usbr.wat.plugins:usbr-simulation-report:${usbr_version}"

    usbr_jasper "usbr.wat.plugins:usbr-actionpanel-jasper:${usbr_version}@zip"
    addl_wat_jars "gov.usbr:usbr-jasper-fonts:${jasper_fonts_version}"

    usbr_python_report "usbr.wat.plugins:usbr-actionpanel-python:${usbr_version}@zip"

    usbr_python_git "usbr.wat.plugins:usbr-wtmp-git-tool:${usbr_git_version}@zip"

    configurations.usbr_plugins.exclude group: "mil.army.usace.hec.wat"
}

static boolean filterOriginalWatZip(FileVisitDetails fvd) {
    // We don't use FIA, HMS, and swap WAT's ResSim 2.5 for ResSim 4.0.
    def path = fvd.getRelativePath();
    return path.contains("/apps/") || path.contains("S25FIAPlugin.jar") ||
            path.contains("S10HMSPlugin") || path.contains("S15ResSimPlugin-v3.5")
}

task assembleInstaller(type: Sync) { task ->

    task.into project.buildDir

    // The base WAT installer
    task.into("WTMP") { intoDir ->
        configurations.wat_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipTree ->
                zipTree.exclude { fvd -> return filterOriginalWatZip(fvd) }
                zipTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-WAT entry
                    segmentList.remove(1)
                    fcd.relativePath = new RelativePath(true, (String[])(segmentList.toArray()))
                }
                zipTree.includeEmptyDirs = false
                zipTree.include '**/*.config'
                zipTree.filter{ line -> line.replaceAll('-Xmx6g', '-Xmx10g')}
            }
        }
    }

    // The base WAT installer
    task.into("WTMP") { intoDir ->
        configurations.wat_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipTree ->
                zipTree.exclude { fvd -> return filterOriginalWatZip(fvd) }
                zipTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-WAT entry
                    segmentList.remove(1)
                    fcd.relativePath = new RelativePath(true, (String[])(segmentList.toArray()))
                }
                zipTree.includeEmptyDirs = false
                zipTree.exclude '**/*.config'
            }
        }
    }

    // Additional jars into WAT/jar (eg Jasper fonts)
    task.into("WTMP/HEC-WAT/jar") { intoDir ->
        from configurations.addl_wat_jars.setTransitive(false).copy()
    }

    // The plugin jars go in jar/ext
    task.into("WTMP/HEC-WAT/jar/ext") { intoDir ->
        from configurations.wat_plugins.setTransitive(false).copy()
    }

    // The plugin jars go in jar/ext
    task.into("WTMP/HEC-WAT/jar/ext") { intoDir ->
        from configurations.usbr_plugins.setTransitive(false).copy()
    }

    // Plugin dependencies go into jar/sys
    task.into("WTMP/HEC-WAT/jar/sys") { intoDir ->
        from configurations.usbr_plugins.setTransitive(true).copyRecursive() - configurations.usbr_plugins.setTransitive(false).copy()
    }

    task.into("WTMP/HEC-WAT/AutomatedReport") { intoDir ->
        configurations.usbr_python_report.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipFileTree ->
                zipFileTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    segmentList.remove(3)
                    fcd.relativePath = new RelativePath(true, (String[])segmentList.toArray())
                }
                zipFileTree.includeEmptyDirs = false
            }
        }
    }

    task.into("WTMP/reports/jasper") { intoDir ->
        configurations.usbr_jasper.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipFileTree ->
                zipFileTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    segmentList.remove(3)
                    fcd.relativePath = new RelativePath(true, (String[])segmentList.toArray())
                }
                zipFileTree.includeEmptyDirs = false
            }
        }
    }

    task.into("WTMP/tools") { intoDir ->
        configurations.usbr_python_git.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipFileTree ->
                zipFileTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    segmentList.remove(2)
                    fcd.relativePath = new RelativePath(true, (String[])segmentList.toArray())
                }
                zipFileTree.includeEmptyDirs = false
            }
        }
    }

    // The right version of ResSim
    task.into("WTMP/apps/HEC-ResSim") { intoDir ->
        configurations.ressim_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipFileTree ->
                zipFileTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-ResSim entry
                    segmentList.remove(3)
                    fcd.relativePath = new RelativePath(true, (String[])(segmentList.toArray()))
                }
                zipFileTree.includeEmptyDirs = false
            }
        }
    }

    task.into("WTMP/apps/ceQualW2/exe") { intoDir ->
        // These will take whatever name is grabbed out of Nexus
        intoDir.from configurations.cequalw2_exe
        intoDir.from configurations.cequalw2_TCD_exe
        intoDir.from(configurations.w2_pre_exe) { fromFile ->
            // Explicitly named as the WAT Plugin looks for this.
            fromFile.rename { "Console_PreW2.exe" }
        }
        intoDir.from(configurations.w2_post_exe) { fromFile ->
            // Explicitly named as the WAT Plugin looks for this.
            fromFile.rename { "W2_Post3.exe" }
        }
    }

    task.into("WTMP/apps/ceQualW2/exec_45") { intoDir ->
        // These will take whatever name is grabbed out of Nexus
        intoDir.from configurations.cequalw2_45_exes
    }

    // There will be duplicates between WAT and the plugins. Just ignore them for now.
    task.duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
}

task wtmpInstaller(type: Zip){
    dependsOn assembleInstaller

    from 'build/WTMP'

    def baseName = 'WTMP'
    def version_no_platform = getShortVersionName() + getBuildID()
    def version = version_no_platform + "-win-x86_64"

    destinationDirectory = file("$buildDir")
    archiveBaseName = baseName
    archiveVersion = version
    archiveExtension = 'zip'

    def buildSpecificSubdir = baseName + '-' + version_no_platform

    includeEmptyDirs false

    // In the archive, put it in a subfolder with the build name
    eachFile { fileCopyDetails ->
        fileCopyDetails.setRelativePath(fileCopyDetails.getRelativePath().prepend(buildSpecificSubdir))
    }
}

/**
 * To help people understand how the versioning
 * interacts with the git repo
 */
task showGit () {
    doFirst {
        def gitInfo = versionDetails()
        println( "Used:    " + getVersion() ) // The select version (the project.version field)
        println( "Tag:     " + gitInfo.lastTag) // actual tag or commit hash(short) if no tag
        println( "Hash:    " + gitInfo.gitHash) // short commit hash
        println( "Branch:  " + gitInfo.branchName) // branch name (null if tag checkout)
        println( "TagBuild:" + gitInfo.isCleanTag) // true if repoi is in dettached head mode(e.g. git checkout <tag>)
    }
}

configure(assembleInstaller) {
    group = 'application'
    description = 'Assembles the WTMP Install for local testing.'
}

configure(wtmpInstaller) {
    group = 'application'
    description = 'Build the WTMP Installer Package'
}

configure(showGit) {
    group = 'help'
    description = 'Shows Git Tag Versioning information'
}

publishing {
    publications {
        maven(MavenPublication) {
            artifactId = "usbr-wtmp-package"
            def verWithExt = getShortVersionName() + "-win-x86_64"
            if(project.version.contains("SNAPSHOT")) {
                verWithExt += "-SNAPSHOT"
            }
            it.version = verWithExt
            artifact source: wtmpInstaller, extension: 'zip'
        }
    }
    repositories {
        maven {
            credentials {
                username = project.hasProperty('rmaNexusUser') ? "$rmaNexusUser" : "defaultUser"
                password = project.hasProperty('rmaNexusPassword') ? "$rmaNexusPassword" : "defaultPassword"
            }
            afterEvaluate {
                url = version.toString().endsWith("SNAPSHOT") ?
                        "https://does-not-publish-snapshots.invalid/url" :
                        "https://artifact.rmanet.app/repository/usbr-releases/"
            }
        }
    }
}