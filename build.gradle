def checkForNexusCredentials() {
    if(!project.hasProperty('nexusUser')) {
        println ('Please set the nexusUser property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PnexusUser= .')
    }
    if(!project.hasProperty('nexusPassword')) {
        println ('Please set the nexusPassword property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PnexusPassword= .')
    }
}

def checkForRMANexusCredentials() {
    if(!project.hasProperty('rmaNexusUser')) {
        println ('Please set the rmaNexusUser property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PrmaNexusUser= .')
    }
    if(!project.hasProperty('rmaNexusPassword')) {
        println ('Please set the rmaNexusPassword property in the GRADLE_USER_HOME ($userHome/.gradle/gradle.properties) file or via -PrmaNexusPassword= .')
    }
}

plugins {
    id "application"
    id "maven-publish"
    id "com.palantir.git-version" version "3.0.0"
    id "org.ajoberstar.grgit" version "4.1.1"
}

def versionLabel(gitInfo) {
    def branch = gitInfo.branchName // all branches are snapshots, only tags get released
    def tag = gitInfo.lastTag
    // tag is returned as is. Branch may need cleanup
    return branch == null ? tag : branch.replace("/","-") + "-SNAPSHOT"
}

group = 'gov.usbr'
version = versionLabel(versionDetails())

/**
 * When running on the Build System (eg TeamCity) will get BUILD_NUMBER
 * Otherwise, gets the current commit (and status)
 */
String getBuildID() {
    if(project.version.contains("-SNAPSHOT")) {
        def buildNum = System.env.BUILD_NUMBER
        if (!buildNum?.trim()) {
            buildNum = "-${grgit.head().abbreviatedId}"
            def clean = grgit.status().isClean()
            if (!clean) {
                buildNum += "+"
            }
        } else {
            buildNum = "." + buildNum
        }
        return buildNum
    } else {
        // If dirty, return "+"
        return grgit.status().isClean() ? "" : "+"
    }
}

String getShortVersionName() {
    String shortVersion = project.version
    if(shortVersion.contains("-SNAPSHOT")) {
        shortVersion = shortVersion.substring(0, shortVersion.indexOf("-SNAPSHOT"))
    }
    return shortVersion
}

repositories {
    maven {
        url 'https://www.hec.usace.army.mil/nexus/repository/maven-public'
    }
    maven {
        url 'https://www.hec.usace.army.mil/nexus/repository/hec-internal'
        credentials {
            checkForNexusCredentials()
            username "$nexusUser"
            password "$nexusPassword"
        }
    }
    maven {
        url 'https://artifact.rmanet.app/repository/rma-internal'
        credentials {
            checkForRMANexusCredentials()
            username "$rmaNexusUser"
            password "$rmaNexusPassword"
        }
    }
    mavenCentral()
    maven {
        url 'https://jaspersoft.jfrog.io/jaspersoft/third-party-ce-artifacts/'
    }
}

configurations {
    // The base WAT install
    wat_install
    // The extra upstream WAT plugins
    wat_plugins
    // The specific ResSim we want to use
    ressim_install
    // W2 Pre EXE, fixed name
    w2_pre_exe
    // W2 Post EXE, fixed name
    w2_post_exe
    // CeQualW2 executable
    cequalw2_exe
    // The TCD Variant required sometimes
    cequalw2_TCD_exe
    // Another TCD variant required sometimes
    cequalw2_TCD_0817_exe
    // v5 TCD variant
    cequalw2_TCD_v5_exe
    // CeQualW2 4.5 executable set
    cequalw2_45_exes
    // Folsom Exe required by some users
    cequalw2_folsom_exe
    // Extra Jars
    addl_wat_jars
    // Extra Jars
    addl_wat_firstparty_jars
    // The USBR WAT Plugins
    usbr_plugins
    // Python Report Generating code
    usbr_python_report
    // Python Git Tool
    usbr_python_git
    // Jasper files
    usbr_jasper
    // Additional WAT Natives
    addl_wat_natives
}

// Version definitions relocated to gradle/libs.versions.toml

dependencies {
    wat_install "mil.army.usace.hec.wat:wat-install-package-rss-4.0:${libs.versions.wat.get()}-win-x86_64@zip"

    wat_plugins libs.bundles.wat.plugins

    w2_pre_exe "edu.pdx.ce.w2:w2-pre:${libs.versions.w2pre.get()}!!@exe"
    w2_post_exe "edu.pdx.ce.w2:w2-post:${libs.versions.w2post.get()}!!@exe"
    cequalw2_exe "edu.pdx.ce.w2:w2:${libs.versions.cequalw2.exe.get()}!!@exe"
    cequalw2_TCD_exe "edu.pdx.ce.w2:w2:${libs.versions.cequalw2.tcd.exe.get()}!!@exe"
    cequalw2_TCD_0817_exe "edu.pdx.ce.w2:w2:${libs.versions.cequalw2.tcd081721.exe.get()}!!@exe"
    cequalw2_TCD_v5_exe(libs.cequalw2.v5.tcd) {
        artifact {
            type = "exe"
        }
    }

    cequalw2_45_exes "edu.pdx.ce.w2:w2:${libs.versions.cequalw2.v45.exe.get()}!!@exe"
    cequalw2_45_exes "edu.pdx.ce.w2:w2-pre-console:${libs.versions.cequalw2preconsole.v45.exe.get()}!!@exe"
    cequalw2_45_exes "edu.pdx.ce.w2:w2-pre:${libs.versions.cequalw2pre.v45.exe.get()}!!@exe"

    cequalw2_folsom_exe "edu.pdx.ce.w2:w2:${libs.versions.cequalw2.folsom.exe.get()}!!@exe"

    ressim_install "mil.army.usace.hec.ressim:hec-ressim:${libs.versions.ressim.zip.get()}!!@zip"

    usbr_plugins(libs.bundles.usbr.plugins){
        exclude group: "mil.army.usace.hec"
        exclude group: "com.rmanet", module: "rmadev"
    }

    usbr_jasper "usbr.wat.plugins:usbr-actionpanel-jasper:${libs.versions.usbr.plugin.get()}!!@zip"
    addl_wat_jars libs.jasper.fonts

    // Filtering out Jackson jars from WAT drops this jar, which USBR Plugins do not pull in. Add it back
    addl_wat_jars libs.jackson.json
    addl_wat_jars libs.jarhdf5

    // This is a hack until ResSim publishes a proper Gradle Platform/Maven BOM. This needs to be revisited them.
    addl_wat_firstparty_jars(libs.ressim.gvdl) {
        exclude group: '*'
    }

    addl_wat_natives libs.jhdf5.win.x8664

    usbr_python_report "usbr.wat.plugins:usbr-actionpanel-python:${libs.versions.usbr.plugin.get()}!!@zip"

    usbr_python_git "usbr.wat.plugins:usbr-wtmp-git-tool:${libs.versions.usbr.git.get()}!!@zip"

    configurations.usbr_plugins.exclude group: "mil.army.usace.hec.wat"
}

configurations.all {
    // This results in a duplicate jar if anything depends on just plain Jython (eg compile-time needs
    // access to Jython APIs) because WAT uses jython-standalone. Both jython and jython-standalone on
    // the classpath results in script failures. Exclude Jython, in favor of WAT's jython-standalone which
    // contains a superset of jython.
    exclude group: 'org.python', module: 'jython'
}

static boolean filterOriginalWatZip(FileVisitDetails fvd) {
    // We don't use FIA, HMS, and swap WAT's ResSim 2.5 for ResSim 4.0.
    def path = fvd.getRelativePath();
    return path.contains("/apps/") || path.contains("S25FIAPlugin.jar") ||
            path.contains("S10HMSPlugin") || path.contains("S15ResSimPlugin-v3.5") ||
            path.contains("S20RASPlugin") || path.contains("fcPlugin-1.1-") ||
            path.contains("hsPlugin-1.1-") || path.contains("sdi-1.1-") ||
            path.contains("pm-1.1-") || path.contains("wat-plugin-ressim-3.5") ||
            // Exclude older Jackson jars that come from WAT, since USBR Plugins include newer Jackson jars
            (path.contains("jackson-") && path.endsWithIgnoreCase("-2.11.0.jar")) ||
            path.contains("gvdl-util")
}

def getGVDLUtilJarName() {
    libs.ressim.gvdl.get().module.name + "-" + libs.versions.ressim.gvdl.get() + ".jar"
}

task assembleInstaller(type: Sync) { task ->

    task.into project.buildDir

    // The base WAT installer
    task.into("WTMP") { intoDir ->
        configurations.wat_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipTree ->
                zipTree.exclude { fvd -> return filterOriginalWatZip(fvd) }
                zipTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-WAT entry
                    segmentList.remove(1)
                    fcd.relativePath = new RelativePath(true, (String[])(segmentList.toArray()))
                }
                zipTree.includeEmptyDirs = false
                zipTree.include '**/*.config'
                zipTree.include '**/*.template'
                zipTree.filter{ line -> {
                    var updatedLine = line.replaceAll('-Xmx6g', '-Xmx10g')
                    if(updatedLine.contains("-Dapp.Version")) {
                        // app.version is the last line in WAT config, so append this to the end
                       updatedLine += ("\n\n" +
                               "# +--------------------------+\n" +
                               "# | WTMP Specific Parameters |\n" +
                               "# +--------------------------+\n" +
                               "vmparam -Djavax.net.ssl.trustStoreType=WINDOWS-ROOT\n" + 
                               "vmparam -Dw2.iterative.compute=true\n" +
                               "vmparam -Dlogback.configurationFile=./config/properties/logback.xml\n" +
                               "vmparam -DEnableSkipModelsMenu=true\n" +
                               "#vmparam -DWTMP.HasUpdateData=true\n" +
                               "#vmparam -DWTMP.HasGit=true")
                    }
                    if(updatedLine.contains("gvdl-util")) {
                        updatedLine = "addjar jar/" + getGVDLUtilJarName()
                    }
                    return updatedLine
                }}
            }
        }
    }

    task.into("WTMP") { intoDir ->
        configurations.wat_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipTree ->
                zipTree.exclude { fvd -> return filterOriginalWatZip(fvd) }
                zipTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-WAT entry
                    segmentList.remove(1)
                    fcd.relativePath = new RelativePath(true, (String[])(segmentList.toArray()))
                }
                zipTree.includeEmptyDirs = false
                zipTree.include '**/*.properties'
                zipTree.filter{ line ->
                    {
                        var updatedLine = line.replaceAll('FINER', 'INFO').replaceAll('FINEST', 'INFO').replaceAll('FINE', 'INFO')
                        return updatedLine
                    }
                }
            }
        }
    }

    // The base WAT installer
    task.into("WTMP") { intoDir ->
        configurations.wat_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipTree ->
                zipTree.exclude { fvd -> return filterOriginalWatZip(fvd) }
                zipTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-WAT entry
                    segmentList.remove(1)
                    fcd.relativePath = new RelativePath(true, (String[])(segmentList.toArray()))
                }
                zipTree.includeEmptyDirs = false
                zipTree.exclude '**/*.config'
                zipTree.exclude '**/*.template'
                zipTree.exclude '**/*.properties'
            }
        }
    }

    // WTMP-specific addon files
    task.into("WTMP") { intoDir ->
        from("install")
    }

    // Additional jars into WAT/jar (eg Jasper fonts)
    task.into("WTMP/HEC-WAT/jar/sys") { intoDir ->
        from configurations.addl_wat_jars.setTransitive(false).copy()
        // Plugin dependencies go into jar/sys
        from configurations.usbr_plugins.setTransitive(true).copyRecursive() - configurations.usbr_plugins.setTransitive(false).copy()
    }

    // Additional jars into WAT/jar (eg Jasper fonts)
    task.into("WTMP/HEC-WAT/jar") { intoDir ->
        from configurations.addl_wat_firstparty_jars.setTransitive(false).copy()
    }

    // Additional natives into WAT/lib (eg Jasper fonts)
    task.into("WTMP/HEC-WAT/lib") { intoDir ->
        configurations.addl_wat_natives.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile))
        }
    }

    // The plugin jars go in jar/ext
    task.into("WTMP/HEC-WAT/jar/ext") { intoDir ->
        from configurations.wat_plugins.setTransitive(false).copy()
        from configurations.usbr_plugins.setTransitive(false).copy()
    }

    task.into("WTMP") { intoDir ->
        configurations.usbr_python_report.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile))
        }
    }

    task.into("WTMP") { intoDir ->
        configurations.usbr_jasper.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile))
        }
    }

    task.into("WTMP") { intoDir ->
        configurations.usbr_python_git.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile))
        }
    }

    // The right version of ResSim
    task.into("WTMP/apps/HEC-ResSim") { intoDir ->
        configurations.ressim_install.asFileTree.each { zipFile ->
            intoDir.from(zipTree(zipFile)) { zipFileTree ->
                zipFileTree.eachFile { fcd ->
                    def segmentList = fcd.relativePath.segments.toList()
                    // Duplicate HEC-ResSim entry
                    segmentList.remove(3)
                    fcd.relativePath = new RelativePath(true, (String[]) (segmentList.toArray()))
                }
                zipFileTree.includeEmptyDirs = false
            }
        }
    }

    task.into("WTMP/apps/ceQualW2/exe") { intoDir ->
        // These will take whatever name is grabbed out of Nexus
        intoDir.from configurations.cequalw2_exe
        intoDir.from configurations.cequalw2_TCD_exe
        intoDir.from(configurations.w2_pre_exe) { fromFile ->
            // Explicitly named as the WAT Plugin looks for this.
            fromFile.rename { "Console_PreW2.exe" }
        }
        intoDir.from(configurations.w2_post_exe) { fromFile ->
            // Explicitly named as the WAT Plugin looks for this.
            fromFile.rename { "W2_Post3.exe" }
        }
        intoDir.from(configurations.cequalw2_TCD_0817_exe) { fromFile ->
            // Explicitly named as the WAT Plugin looks for this.
            fromFile.rename { "W2_TCD_081721.exe" }
        }
    }

    task.into("WTMP/apps/ceQualW2/exec_45") { intoDir ->
        // These will take whatever name is grabbed out of Nexus
        intoDir.from configurations.cequalw2_45_exes
        intoDir.from(configurations.cequalw2_TCD_v5_exe)
        intoDir.from(configurations.cequalw2_folsom_exe) { fromFile ->
            // Explicitly named as the WAT Plugin looks for this.
            fromFile.rename { "w2_v45_64_Folsom.exe" }
        }
    }

    // There will be duplicates between WAT and the plugins. Just ignore them for now.
    task.duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
}

task wtmpInstaller(type: Zip){
    dependsOn assembleInstaller

    from 'build/WTMP'

    def baseName = 'WTMP'
    def version_no_platform = getShortVersionName() + getBuildID()
    def version = version_no_platform + "-win-x86_64"

    destinationDirectory = file("$buildDir")
    archiveBaseName = baseName
    archiveVersion = version
    archiveExtension = 'zip'

    def buildSpecificSubdir = baseName + '-' + version_no_platform

    includeEmptyDirs false

    // In the archive, put it in a subfolder with the build name
    eachFile { fileCopyDetails ->
        fileCopyDetails.setRelativePath(fileCopyDetails.getRelativePath().prepend(buildSpecificSubdir))
    }
}

/**
 * To help people understand how the versioning
 * interacts with the git repo
 */
task showGit () {
    doFirst {
        def gitInfo = versionDetails()
        println( "Used:    " + getVersion() ) // The select version (the project.version field)
        println( "Tag:     " + gitInfo.lastTag) // actual tag or commit hash(short) if no tag
        println( "Hash:    " + gitInfo.gitHash) // short commit hash
        println( "Branch:  " + gitInfo.branchName) // branch name (null if tag checkout)
        println( "TagBuild:" + gitInfo.isCleanTag) // true if repoi is in dettached head mode(e.g. git checkout <tag>)
    }
}

configure(assembleInstaller) {
    group = 'application'
    description = 'Assembles the WTMP Install for local testing.'
}

configure(wtmpInstaller) {
    group = 'application'
    description = 'Build the WTMP Installer Package'
}

configure(showGit) {
    group = 'help'
    description = 'Shows Git Tag Versioning information'
}

publishing {
    publications {
        maven(MavenPublication) {
            artifactId = "usbr-wtmp-package"
            def verWithExt = getShortVersionName() + "-win-x86_64"
            if(project.version.contains("SNAPSHOT")) {
                verWithExt += "-SNAPSHOT"
            }
            it.version = verWithExt
            artifact source: wtmpInstaller, extension: 'zip'
        }
    }
    repositories {
        maven {
            credentials {
                username = project.hasProperty('rmaNexusUser') ? "$rmaNexusUser" : "defaultUser"
                password = project.hasProperty('rmaNexusPassword') ? "$rmaNexusPassword" : "defaultPassword"
            }
            afterEvaluate {
                url = version.toString().endsWith("SNAPSHOT") ?
                        "https://does-not-publish-snapshots.invalid/url" :
                        "https://artifact.rmanet.app/repository/usbr-releases/"
            }
        }
    }
}
